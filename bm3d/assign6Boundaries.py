# Autogenerated with SMOP 0.32-7-gcce8558
from smop.core import *
# assign6Boundaries.m

    
@function
def assign6Boundaries(L=None,bbVol=None,*args,**kwargs):
    varargin = assign6Boundaries.varargin
    nargin = assign6Boundaries.nargin

    voxelCount=numel(L)
# assign6Boundaries.m:3
    dims=size(L)
# assign6Boundaries.m:4
    boundaries=find(L == 0)
# assign6Boundaries.m:5
    newBoundaryAssignments=zeros(numel(boundaries),1)
# assign6Boundaries.m:6
    ## ASSIGN EACH VOXEL ON THE WATERSHED BOUNDARY TO A 6-NEIGHBOR OBJECT (INCLUDING BACKGROUND) BASED ON COLOR
## WATERSHED DOMAINS MUST BE CALCULATED BY 6-CONNECTIVITY
    iterCount=1
# assign6Boundaries.m:9
    while logical_not(isempty(boundaries)):

        for kk in arange(1,numel(boundaries)).reshape(-1):
            thisVox=boundaries[kk]
# assign6Boundaries.m:12
            thisVal=matlabarray([])
# assign6Boundaries.m:13
            for dd in arange(1,size(bbVol,4)).reshape(-1):
                thisVal=matlabarray(cat(thisVal,bbVol[thisVox + dot((dd - 1),voxelCount)]))
# assign6Boundaries.m:15
            xx,yy,zz=ind2sub(dims,thisVox,nargout=3)
# assign6Boundaries.m:17
            validNeighbors=valid26Neighbors(xx,yy,zz,dims)
# assign6Boundaries.m:18
            validIdx=sub2ind(dims,validNeighbors[:,1],validNeighbors[:,2],validNeighbors[:,3])
# assign6Boundaries.m:19
            validIdx[L[validIdx] == 0]=[]
# assign6Boundaries.m:20
            if logical_not(isempty(validIdx)):
                validVal=matlabarray([])
# assign6Boundaries.m:22
                for dd in arange(1,size(bbVol,4)).reshape(-1):
                    validVal=matlabarray(cat(validVal,bbVol[validIdx + dot((dd - 1),voxelCount)]))
# assign6Boundaries.m:24
                allNormSq=sum((validVal - repmat(thisVal,numel(validIdx),1)) ** 2,2)
# assign6Boundaries.m:26
                mini,pos=min(allNormSq,nargout=2)
# assign6Boundaries.m:27
                newBoundaryAssignments[kk]=L[validIdx[pos]]
# assign6Boundaries.m:28
        L[boundaries]=newBoundaryAssignments
# assign6Boundaries.m:31
        boundaries=find(L == 0)
# assign6Boundaries.m:32
        newBoundaryAssignments=zeros(numel(boundaries),1)
# assign6Boundaries.m:33
        iterCount=iterCount + 1
# assign6Boundaries.m:34

    
    disp(iterCount)
    #########################################################################################################################################################################
    
@function
def valid26Neighbors(xx=None,yy=None,zz=None,dims=None,*args,**kwargs):
    varargin = valid26Neighbors.varargin
    nargin = valid26Neighbors.nargin

    tmp=matlabarray(cat([cat(xx - 1,yy - 1,zz - 1)],[cat(xx - 1,yy - 1,zz)],[cat(xx - 1,yy - 1,zz + 1)],[cat(xx - 1,yy,zz - 1)],[cat(xx - 1,yy,zz)],[cat(xx - 1,yy,zz + 1)],[cat(xx - 1,yy + 1,zz - 1)],[cat(xx - 1,yy + 1,zz)],[cat(xx - 1,yy + 1,zz + 1)],[cat(xx,yy - 1,zz - 1)],[cat(xx,yy - 1,zz)],[cat(xx,yy - 1,zz + 1)],[cat(xx,yy,zz - 1)],[cat(xx,yy,zz + 1)],[cat(xx,yy + 1,zz - 1)],[cat(xx,yy + 1,zz)],[cat(xx,yy + 1,zz + 1)],[cat(xx + 1,yy - 1,zz - 1)],[cat(xx + 1,yy - 1,zz)],[cat(xx + 1,yy - 1,zz + 1)],[cat(xx + 1,yy,zz - 1)],[cat(xx + 1,yy,zz)],[cat(xx + 1,yy,zz + 1)],[cat(xx + 1,yy + 1,zz - 1)],[cat(xx + 1,yy + 1,zz)],[cat(xx + 1,yy + 1,zz + 1)]))
# assign6Boundaries.m:40
    tmp[:,1]=min(max(1,tmp[:,1]),dims[1])
# assign6Boundaries.m:43
    tmp[:,2]=min(max(1,tmp[:,2]),dims[2])
# assign6Boundaries.m:44
    tmp[:,3]=min(max(1,tmp[:,3]),dims[3])
# assign6Boundaries.m:45